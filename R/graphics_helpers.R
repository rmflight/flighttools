#' use ggplot2 colors
#' 
#' generates the code for getting some ggplot2 colors
#' 
#' @family {Graphics} 
#' @family {Code Generators}
#' @family {Colors}
#' @export
#' @return string
ft_ggplot2_colors = function()
{
  cat('ggplot2::scale_color_discrete()$palette(n)', sep = "\n")
}

#' rotate axis labels
#' 
#' Gives me the code to rotate axis labels.
#' 
#' @family {Graphics} 
#' @family {Code Generators}
#' @export
#' @return string
ft_ggplot2_rotate_axis_labels = function()
{
  cat('scale_x_discrete(guide = guide_axis(angle = 90))',
      'theme(axis.text.x=element_text(angle = 90)',
      'coord_flip()', sep = "\n\n")
}


#' add numbers to figure files
#' 
#' Given that `rmd` and `qmd` chunks are **normally** run sequentially, figures
#' should be generated in order that they are presented in the document. Therefore,
#' we should be able to roughly match them up with numbering generated by cross-referencing
#' using the modified times.
#' 
#' @param figure_directory the directory containing figure files
#' @param start_count what number starts the counting
#' @param count_location should the count be a `prefix` or `suffix`?
#' @param skip_numbers should any numbers be skipped due to inserting from a different location?
#' @param regexp what regex should be used to grab files
#' 
#' @family {Graphics}
#' @family {File Manipulation}
#' @export
#' @return NULL
ft_add_figure_numbers = function(figure_directory = ".",
                                 start_count = 1,
                                 count_location = "prefix",
                                 skip_numbers = NULL,
                                 regexp = "jpg$|png$|svg$")
{
  figure_files = fs::dir_ls(figure_directory, regexp = regexp)
  file_data = fs::file_info(figure_files)
  file_data$bare_path = fs::path_dir(file_data$path)
  file_data$file_no_ext = fs::path_ext_remove(fs::path_file(file_data$path))
  file_data$ext = fs::path_ext(file_data$path)
  
  mod_time = file_data |>
    dplyr::select(tidyselect::all_of(c("modification_time", "file_no_ext"))) |>
    dplyr::group_by(.data$file_no_ext) |>
    dplyr::slice_head(n = 1) |>
    dplyr::ungroup() |>
    dplyr::arrange(.data$modification_time) |>
    dplyr::mutate(figure_number = seq_len(dplyr::n()))
  
  if (!is.null(skip_numbers)) {
    # do something
  }
  
  file_data = dplyr::left_join(file_data, mod_time |> dplyr::select(tidyselect::all_of(c("file_no_ext", "figure_number"))), by = "file_no_ext")
  if (count_location %in% "prefix") {
    file_data$new_file = paste0("Figure_", file_data$figure_number, "_", file_data$file_no_ext, ".", file_data$ext)
  } else if (count_location %in% "suffix") {
    file_data$new_file = paste0(file_data$file_no_ext, "_Figure_", file_data$figure_number, ".", file_data$ext)
  }
  file_data$new_path = fs::path(file_data$bare_path, file_data$new_file)
  
  fs::file_move(file_data$path, file_data$new_path)
  file_data[, c("path", "new_path")]
}

#' generate ComplexHeatmap color scale
#' 
#' The code for creating a function that maps values to colors for `ComplexHeatmap`
#' heatmaps is not easy for me to remember. Here it is.
#' 
#' @details
#' My favorite colors to use include:
#'   
#' * `viridis::viridis`
#' * `scico::scico(n, palette = "vik")`
#' 
#' You can also use `scico::scico_palette_show()` to see other colorblind safe palettes.
#' 
#' @family {Graphics} 
#' @family {Code Generators}
#' @family {Colors}
#' @export
#' @return string
ft_complexheatmap_scale = function()
{
  cat('n_value = 20
circlize::colorRamp2(seq(low, high, length.out = n_value), viridis::viridis(n_value))

or

circlize::colorRamp2(seq(low, high, length.out = n_value), scico::scico(n_value, palette = "vik"))')
}

#' add data ellipse
#' 
#' Adds an ellipse showing the extent of the data to a plot. Most useful for PCA
#' type stuff to show whether the samples separate or not.
#' 
#' @family {Graphics} {Code Generators}
#' @export
#' @return a string
ft_ggplot2_add_ellipse = function()
{
  cat('geom_polygon(stat = "ellipse", aes(fill = aes_fill, color = aes_color))')
}

#' discretize a continuous colorscale
#' 
#' When one is using a continuous colorscale to visualize data (say log-fold-changes or correlations),
#' it may be useful to create discrete colors from a usually continuous color scale.
#' 
#' @param color_scale the color scale to take colors from
#' @param discrete_n how many colors to take
#' @param discrete_locs where to take them from
#' @param show_colors create a plot showing the continuous and discrete colors
#' 
#' @examples
#' if (require("scico")) {
#'   ft_discretize_colorscale(scico::scico(100, palette = "vanimo", direction = -1),
#'                            discrete_locs = c(20, 80))
#' }
#' 
#' @family {Graphics}
#' @family {Colors}
#' @export
#' @return vector of colors
ft_discretize_colorscale = function(color_scale = NULL,
                                    discrete_locs = c(25, 75),
                                    show_colors = TRUE)
{
  # color_scale = scico::scico(100, palette = "vanimo", direction = -1)
  # discrete_locs = c(20, 80)
  if (is.null(color_scale)) {
    cli::cli_abort(
      message = c('{.arg color_scale} must be specified!',
                  'x' = 'Currently {.code color_scale = NULL}.',
                  'i' = 'See ?scico::scico or ?viridis::turbo to create a vector of colors.')
    )  
    stop("Please supply a list of colors or a function to generate them!")
  }
  
  n_color = length(color_scale)
  if (any(discrete_locs > n_color)) {
    cli::cli_abort(
      message = c('Values in {.arg discrete_locs} must be less than the length of {.arg color_scale}!',
                  'x' = 'Length of {.arg color_scale} is {n_color}, and {.code discrete_locs} is {discrete_locs}')
    )
  }
  
  out_colors = color_scale[c(discrete_locs)]
  
  if (show_colors) {
    select_matrix = matrix(seq_len(n_color), ncol = 1)
    select_cols = rep("#FFFFFF", n_color)
    select_cols[discrete_locs] = "#000000"
    dims = grDevices::n2mfrow(3)
    oldpar = par(mfrow = dims, mai = par("mai")/5)
    on.exit(par(oldpar))
    image(matrix(seq_len(n_color), ncol = 1), col = color_scale, main = "color_scale", axes = FALSE)
    image(select_matrix, col = select_cols, main = "selections", axes = FALSE)
    image(matrix(seq_len(length(out_colors)), ncol = 1), col = out_colors, main = "discretized", axes = FALSE)
  }
  return(out_colors)
}

#' save plot to temp
#' 
#' Take a plot object (default is `ggplot2::last_plot()`), and write it to a file
#' that can be easily found and opened in a VSCode editor pane for a zoomed view of the plot.
#' 
#' @param in_plot the plot to save
#' @param filename the file to save it to. Default is underscore to make it easily findable
#' @param width width of the saved plot
#' @param height height of the saved plot
#' @param units units to use
#' @param res the resolution
#' @param ... other parameters to `ragg::agg_png()`
#' 
#' @seealso [ragg::agg_png()]
#' 
#' @return filename
#' @export
ft_plot_temp_file = function(in_plot = ggplot2::last_plot(), filename = "_deleteme_plot.png", 
                                 width = 10, height = 8, 
                                 units = "in", res = 300, ...)
{
  if (!requireNamespace("ragg", quietly = TRUE)) {
    stop("ragg package must be installed.")
  }
  ragg::agg_png(filename = filename, width = width, height = height, units = units, res = res, ...)
  print(in_plot)
  dev.off()
  return(filename)
}

#' define my own colors
#' 
#' Reminds me of the syntax for passing my own colors to a ggplot2 graph
#' 
#' @family {Graphics} {Code Generators}
#' @export
#' @return a string
ft_ggplot2_self_colors = function()
{
  cat('scale_color_manual(values = c("one" = "gray", "two" = "black"))')
}

#' have legend inside plot area
#' 
#' Provides the code necessary for putting a legend inside the plot area.
#' At some point the code for that changed, and I always forget it.
#' 
#' @family {Graphics} {Code Generators}
#' @export
#' @return a string
ft_ggplot2_legend_inside = function()
{
  cat('theme(legend.position = "inside", legend.position.inside = c(0.7, 0.7))')
}
