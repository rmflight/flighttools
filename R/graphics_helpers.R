#' use ggplot2 colors
#'
#' generates the code for getting some ggplot2 colors
#'
#' @family {Graphics}
#' @family {Code Generators}
#' @family {Colors}
#' @family {ggplot2}
#' @examples
#' ft_ggplot2_colors()
#' @export
#' @return string
ft_ggplot2_colors = function() {
  cat('ggplot2::scale_color_discrete()$palette(n)', sep = "\n")
}

#' rotate axis labels
#'
#' Gives me the code to rotate axis labels.
#'
#' @family {Graphics}
#' @family {ggplot2}
#' @family {Code Generators}
#' @examples
#' ft_ggplot2_rotate_axis_labels()
#' @export
#' @return string
ft_ggplot2_rotate_axis_labels = function() {
  cat(
    'scale_x_discrete(guide = guide_axis(angle = 90))',
    'theme(axis.text.x=element_text(angle = 90)',
    'coord_flip()',
    sep = "\n\n"
  )
}


#' add numbers to figure files
#'
#' Given that `rmd` and `qmd` chunks are **normally** run sequentially, figures
#' should be generated in order that they are presented in the document. Therefore,
#' we should be able to roughly match them up with numbering generated by cross-referencing
#' using the modified times.
#'
#' @param figure_directory the directory containing figure files
#' @param start_count what number starts the counting
#' @param count_location should the count be a `prefix` or `suffix`?
#' @param skip_numbers should any numbers be skipped due to inserting from a different location?
#' @param regexp what regex should be used to grab files
#'
#' @family {Graphics}
#' @family {File Manipulation}
#' @export
#' @return NULL
ft_add_figure_numbers = function(
  figure_directory = ".",
  start_count = 1,
  count_location = "prefix",
  skip_numbers = NULL,
  regexp = "jpg$|png$|svg$"
) {
  figure_files = fs::dir_ls(figure_directory, regexp = regexp)
  file_data = fs::file_info(figure_files)
  file_data$bare_path = fs::path_dir(file_data$path)
  file_data$file_no_ext = fs::path_ext_remove(fs::path_file(file_data$path))
  file_data$ext = fs::path_ext(file_data$path)

  mod_time = file_data |>
    dplyr::select(tidyselect::all_of(c("modification_time", "file_no_ext"))) |>
    dplyr::group_by(.data$file_no_ext) |>
    dplyr::slice_head(n = 1) |>
    dplyr::ungroup() |>
    dplyr::arrange(.data$modification_time) |>
    dplyr::mutate(figure_number = seq_len(dplyr::n()))

  if (!is.null(skip_numbers)) {
    # do something
  }

  file_data = dplyr::left_join(
    file_data,
    mod_time |>
      dplyr::select(tidyselect::all_of(c("file_no_ext", "figure_number"))),
    by = "file_no_ext"
  )
  if (count_location %in% "prefix") {
    file_data$new_file = paste0(
      "Figure_",
      file_data$figure_number,
      "_",
      file_data$file_no_ext,
      ".",
      file_data$ext
    )
  } else if (count_location %in% "suffix") {
    file_data$new_file = paste0(
      file_data$file_no_ext,
      "_Figure_",
      file_data$figure_number,
      ".",
      file_data$ext
    )
  }
  file_data$new_path = fs::path(file_data$bare_path, file_data$new_file)

  fs::file_move(file_data$path, file_data$new_path)
  file_data[, c("path", "new_path")]
}

#' generate ComplexHeatmap color scale
#'
#' The code for creating a function that maps values to colors for `ComplexHeatmap`
#' heatmaps is not easy for me to remember. Here it is.
#'
#' @details
#' My favorite colors to use include:
#'
#' * `viridis::viridis`
#' * `scico::scico(n, palette = "vik")`
#'
#' You can also use `scico::scico_palette_show()` to see other colorblind safe palettes.
#'
#' @family {Graphics} {ComplexHeatmap}
#' @family {Code Generators}
#' @family {Colors}
#' @examples
#' ft_complexheatmap_scale()
#' @export
#' @return string
ft_complexheatmap_scale = function() {
  cat(
    'n_value = 20
circlize::colorRamp2(seq(low, high, length.out = n_value), viridis::viridis(n_value))

or

circlize::colorRamp2(seq(low, high, length.out = n_value), scico::scico(n_value, palette = "vik"))'
  )
}

#' add data ellipse
#'
#' Adds an ellipse showing the extent of the data to a plot. Most useful for PCA
#' type stuff to show whether the samples separate or not.
#'
#' @family {Graphics}
#' @family {Code Generators}
#' @family {ggplot2}
#' @examples
#' ft_ggplot2_add_ellipse()
#' @export
#' @return a string
ft_ggplot2_add_ellipse = function() {
  cat('geom_polygon(stat = "ellipse", aes(fill = aes_fill, color = aes_color))')
}

#' discretize a continuous colorscale
#'
#' When one is using a continuous colorscale to visualize data (say log-fold-changes or correlations),
#' it may be useful to create discrete colors from a usually continuous color scale.
#'
#' @param color_scale the color scale to take colors from
#' @param discrete_n how many colors to take
#' @param discrete_locs where to take them from
#' @param show_colors create a plot showing the continuous and discrete colors
#'
#' @examples
#' if (require("scico")) {
#'   ft_discretize_colorscale(scico::scico(100, palette = "vanimo", direction = -1),
#'                            discrete_locs = c(20, 80))
#' }
#'
#' @family {Graphics}
#' @family {Colors}
#' @export
#' @return vector of colors
ft_discretize_colorscale = function(
  color_scale = NULL,
  discrete_locs = c(25, 75),
  show_colors = TRUE
) {
  # color_scale = scico::scico(100, palette = "vanimo", direction = -1)
  # discrete_locs = c(20, 80)
  if (is.null(color_scale)) {
    cli::cli_abort(
      message = c(
        '{.arg color_scale} must be specified!',
        'x' = 'Currently {.code color_scale = NULL}.',
        'i' = 'See ?scico::scico or ?viridis::turbo to create a vector of colors.'
      )
    )
    stop("Please supply a list of colors or a function to generate them!")
  }

  n_color = length(color_scale)
  if (any(discrete_locs > n_color)) {
    cli::cli_abort(
      message = c(
        'Values in {.arg discrete_locs} must be less than the length of {.arg color_scale}!',
        'x' = 'Length of {.arg color_scale} is {n_color}, and {.code discrete_locs} is {discrete_locs}'
      )
    )
  }

  out_colors = color_scale[c(discrete_locs)]

  if (show_colors) {
    select_matrix = matrix(seq_len(n_color), ncol = 1)
    select_cols = rep("#FFFFFF", n_color)
    select_cols[discrete_locs] = "#000000"
    dims = grDevices::n2mfrow(3)
    oldpar = par(mfrow = dims, mai = par("mai") / 5)
    on.exit(par(oldpar))
    image(
      matrix(seq_len(n_color), ncol = 1),
      col = color_scale,
      main = "color_scale",
      axes = FALSE
    )
    image(select_matrix, col = select_cols, main = "selections", axes = FALSE)
    image(
      matrix(seq_len(length(out_colors)), ncol = 1),
      col = out_colors,
      main = "discretized",
      axes = FALSE
    )
  }
  return(out_colors)
}

#' save plot to temp
#'
#' Take a plot object (default is `ggplot2::last_plot()`), and write it to a file
#' that can be easily found and opened in a VSCode editor pane for a zoomed view of the plot.
#'
#' @param in_plot the plot to save
#' @param filename the file to save it to. Default is underscore to make it easily findable
#' @param width width of the saved plot
#' @param height height of the saved plot
#' @param units units to use
#' @param res the resolution
#' @param ... other parameters to `ragg::agg_png()`
#'
#' @seealso [ragg::agg_png()]
#'
#' @return filename
#' @family {Graphics}
#' @export
ft_plot_temp_file = function(
  in_plot = ggplot2::last_plot(),
  filename = "_deleteme_plot.png",
  width = 10,
  height = 8,
  units = "in",
  res = 300,
  ...
) {
  if (!requireNamespace("ragg", quietly = TRUE)) {
    stop("ragg package must be installed.")
  }
  ragg::agg_png(
    filename = filename,
    width = width,
    height = height,
    units = units,
    res = res,
    ...
  )
  print(in_plot)
  dev.off()
  return(filename)
}

#' define my own colors
#'
#' Reminds me of the syntax for passing my own colors to a ggplot2 graph
#'
#' @family {Graphics}
#' @family {Code Generators}
#' @family {ggplot2}
#' @examples
#' ft_ggplot2_self_colors()
#' @export
#' @return a string
ft_ggplot2_self_colors = function() {
  cat('scale_color_manual(values = c("one" = "gray", "two" = "black"))')
}

#' have legend inside plot area
#'
#' Provides the code necessary for putting a legend inside the plot area.
#' At some point the code for that changed, and I always forget it.
#'
#' @family {Graphics}
#' @family {Code Generators}
#' @family {ggplot2}
#' @examples
#' ft_ggplot2_legend_inside()
#' @export
#' @return a string
ft_ggplot2_legend_inside = function() {
  cat('theme(legend.position = "inside", legend.position.inside = c(0.7, 0.7))')
}

#' add more padding
#'
#' Provides the code for adding padding to a plot, which is sometimes necessary
#' when generating UpSet plots via ComplexHeatmap::UpSet, as the labels will
#' be too long and get cutoff.
#'
#' @family {Graphics}
#' @family {Code Generators}
#' @examples
#'   ft_add_padding()
#' @export
#' @return a string
ft_add_padding = function() {
  cat('draw(plot, padding = unit(c(2, 8, 2, 2), "mm"))')
}

#' add counts to UpSet
#'
#' Provides the code for adding column and row counts to UpSet plot intersections
#' and groups.
#'
#' @family {Graphics}
#' @family {Code Generators}
#' @family {UpSet}
#' @examples
#' ft_upset_add_counts()
#' @export
#' @return a string
ft_upset_add_counts = function() {
  cat(
    'UpSet(combinations, top_annotation = upset_top_annotation(combinations, add_numbers = TRUE),
  right_annotation = upset_right_annotation(mismatch_stable_comb, add_numbers = TRUE))'
  )
}

#' manually create combinations
#'
#' Provides a code framework for creating a combination matrix with code instead of using lists.
#' Needed because sometimes `ComplexHeatmap::make_comb_mat` will choke on list elements.
#'
#' @family {Graphics}
#' @family {Code Generators}
#' @family {UpSet}
#' @examples
#'   ft_upset_comb_matrix()
#' @export
#' @return a string
ft_upset_comb_matrix = function() {
  cat(
    'make_combination_matrix = function(list_items) {
  all_items = sort(unique(unlist(list_items)))
  comb_mat = matrix(0, nrow = length(all_items), ncol = length(list_items))
  colnames(comb_mat) = names(list_items)
  
  for (i_out in seq_along(list_items)) {
    comb_mat[all_items %in% list_items[[i_out]], i_out] = 1
  }
  return(comb_mat)
}'
  )
}
